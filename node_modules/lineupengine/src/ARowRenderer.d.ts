import { IAbortAblePromise } from './abortAble';
import { IAnimationContext } from './animation';
import { IExceptionContext } from './logic';
import { EScrollResult, IMixinClass } from './mixin';
import { IDelayedMode } from './internal';
export declare type IRowRenderContext = IExceptionContext;
export interface IRowRendererOptions {
    async: IDelayedMode;
    minScrollDelta: number;
    batchSize: number;
    mixins: IMixinClass[];
    scrollingHint: boolean;
}
export declare abstract class ARowRenderer {
    protected readonly body: HTMLElement;
    private readonly pool;
    private readonly loadingPool;
    private readonly loading;
    private readonly fragment;
    protected readonly visible: {
        first: number;
        forcedFirst: number;
        last: number;
        forcedLast: number;
    };
    protected visibleFirstRowPos: number;
    private readonly adapter;
    private readonly mixins;
    private scrollListener;
    private abortAnimation;
    protected readonly options: Readonly<IRowRendererOptions>;
    constructor(body: HTMLElement, options?: Partial<IRowRendererOptions>);
    protected addMixin(mixinClass: IMixinClass, options?: any): void;
    private createAdapter;
    protected readonly bodyScroller: HTMLElement;
    protected readonly bodySizer: HTMLElement;
    protected abstract readonly context: IRowRenderContext;
    protected abstract createRow(node: HTMLElement, index: number): IAbortAblePromise<void> | void;
    protected abstract updateRow(node: HTMLElement, index: number): IAbortAblePromise<void> | void;
    protected init(): void;
    destroy(): void;
    private static cleanUp;
    private select;
    private selectProxy;
    private recycle;
    private proxy;
    private create;
    private removeAll;
    protected update(): void;
    protected forEachRow(callback: (row: HTMLElement, rowIndex: number) => void, inplace?: boolean): void;
    private removeFromBeginning;
    private removeFromBottom;
    private remove;
    private addAtBeginning;
    private addAtBottom;
    protected updateOffset(firstRowPos: number): void;
    protected updateSizer(firstRowPos: number): void;
    protected recreate(ctx?: IAnimationContext): void;
    private recreatePure;
    private recreateAnimated;
    private animate;
    protected clearPool(): void;
    protected revalidate(): void;
    protected onScrolledVertically(scrollTop: number, clientHeight: number, isGoingDown: boolean): EScrollResult;
    private shiftLast;
    private shiftFirst;
    private onScrolledImpl;
}
export default ARowRenderer;
