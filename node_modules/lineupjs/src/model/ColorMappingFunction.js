import { interpolateBlues, interpolateGreens, interpolateGreys, interpolateOranges, interpolatePurples, interpolateReds, interpolateCool, interpolateCubehelixDefault, interpolateWarm, interpolatePlasma, interpolateMagma, interpolateViridis, interpolateInferno, interpolateYlOrRd, interpolateYlOrBr, interpolateBuGn, interpolateBuPu, interpolateGnBu, interpolateOrRd, interpolatePuBuGn, interpolatePuBu, interpolatePuRd, interpolateRdPu, interpolateYlGnBu, interpolateYlGn, interpolateRainbow, interpolateBrBG, interpolatePRGn, interpolatePiYG, interpolatePuOr, interpolateRdBu, interpolateRdGy, interpolateRdYlBu, interpolateRdYlGn, interpolateSpectral } from 'd3-scale-chromatic';
import Column from './Column';
import { equal } from '../internal/utils';
import { scaleLinear } from 'd3-scale';
var InterpolatingColorFunction = (function () {
    function InterpolatingColorFunction(name, type, apply) {
        this.name = name;
        this.type = type;
        this.apply = apply;
    }
    InterpolatingColorFunction.prototype.dump = function () {
        return this.name;
    };
    InterpolatingColorFunction.prototype.clone = function () {
        return this;
    };
    InterpolatingColorFunction.prototype.eq = function (other) {
        return other === this;
    };
    return InterpolatingColorFunction;
}());
export { InterpolatingColorFunction };
var SolidColorFunction = (function () {
    function SolidColorFunction(color) {
        this.color = color;
    }
    Object.defineProperty(SolidColorFunction.prototype, "type", {
        get: function () {
            return 'solid';
        },
        enumerable: true,
        configurable: true
    });
    SolidColorFunction.prototype.apply = function () {
        return this.color;
    };
    SolidColorFunction.prototype.dump = function () {
        return this.color;
    };
    SolidColorFunction.prototype.clone = function () {
        return this;
    };
    SolidColorFunction.prototype.eq = function (other) {
        return other instanceof SolidColorFunction && other.color === this.color;
    };
    return SolidColorFunction;
}());
export { SolidColorFunction };
var QuantizedColorFunction = (function () {
    function QuantizedColorFunction(base, steps) {
        this.base = base;
        this.steps = steps;
    }
    Object.defineProperty(QuantizedColorFunction.prototype, "type", {
        get: function () {
            return 'quantized';
        },
        enumerable: true,
        configurable: true
    });
    QuantizedColorFunction.prototype.apply = function (v) {
        return this.base.apply(quantize(v, this.steps));
    };
    QuantizedColorFunction.prototype.dump = function () {
        return {
            base: this.base.dump(),
            steps: this.steps
        };
    };
    QuantizedColorFunction.prototype.clone = function () {
        return this;
    };
    QuantizedColorFunction.prototype.eq = function (other) {
        return other instanceof QuantizedColorFunction && other.base.eq(this.base) && other.steps === this.steps;
    };
    return QuantizedColorFunction;
}());
export { QuantizedColorFunction };
var CustomColorMappingFunction = (function () {
    function CustomColorMappingFunction(entries) {
        this.entries = entries;
        this.scale = scaleLinear();
        this.scale
            .domain(entries.map(function (d) { return d.value; }))
            .range(entries.map(function (d) { return d.color; }))
            .clamp(true);
    }
    Object.defineProperty(CustomColorMappingFunction.prototype, "type", {
        get: function () {
            return 'custom';
        },
        enumerable: true,
        configurable: true
    });
    CustomColorMappingFunction.prototype.apply = function (v) {
        return this.scale(v);
    };
    CustomColorMappingFunction.prototype.dump = function () {
        return this.entries;
    };
    CustomColorMappingFunction.prototype.clone = function () {
        return new CustomColorMappingFunction(this.entries);
    };
    CustomColorMappingFunction.prototype.eq = function (other) {
        return other instanceof CustomColorMappingFunction && equal(this.entries, other.entries);
    };
    return CustomColorMappingFunction;
}());
export { CustomColorMappingFunction };
export function quantize(v, steps) {
    var perStep = 1 / steps;
    if (v <= perStep) {
        return 0;
    }
    if (v >= (1 - perStep)) {
        return 1;
    }
    for (var acc = 0; acc < 1; acc += perStep) {
        if (v < acc) {
            return acc - perStep / 2;
        }
    }
    return v;
}
var cache = new Map();
export function asColorFunction(color) {
    if (cache.has(color)) {
        return cache.get(color);
    }
    var s = new SolidColorFunction(color);
    cache.set(color, s);
    return s;
}
export var DEFAULT_COLOR_FUNCTION = asColorFunction(Column.DEFAULT_COLOR);
export var sequentialColors = [];
export var divergentColors = [];
export var lookupInterpolatingColor = new Map();
{
    var sequential = {
        interpolateBlues: interpolateBlues,
        interpolateGreens: interpolateGreens,
        interpolateGreys: interpolateGreys,
        interpolateOranges: interpolateOranges,
        interpolatePurples: interpolatePurples,
        interpolateReds: interpolateReds,
        interpolateCool: interpolateCool,
        interpolateCubehelixDefault: interpolateCubehelixDefault,
        interpolateWarm: interpolateWarm,
        interpolatePlasma: interpolatePlasma,
        interpolateMagma: interpolateMagma,
        interpolateViridis: interpolateViridis,
        interpolateInferno: interpolateInferno,
        interpolateYlOrRd: interpolateYlOrRd,
        interpolateYlOrBr: interpolateYlOrBr,
        interpolateBuGn: interpolateBuGn,
        interpolateBuPu: interpolateBuPu,
        interpolateGnBu: interpolateGnBu,
        interpolateOrRd: interpolateOrRd,
        interpolatePuBuGn: interpolatePuBuGn,
        interpolatePuBu: interpolatePuBu,
        interpolatePuRd: interpolatePuRd,
        interpolateRdPu: interpolateRdPu,
        interpolateYlGnBu: interpolateYlGnBu,
        interpolateYlGn: interpolateYlGn,
        interpolateRainbow: interpolateRainbow
    };
    var divergent = {
        interpolateBrBG: interpolateBrBG,
        interpolatePRGn: interpolatePRGn,
        interpolatePiYG: interpolatePiYG,
        interpolatePuOr: interpolatePuOr,
        interpolateRdBu: interpolateRdBu,
        interpolateRdGy: interpolateRdGy,
        interpolateRdYlBu: interpolateRdYlBu,
        interpolateRdYlGn: interpolateRdYlGn,
        interpolateSpectral: interpolateSpectral
    };
    for (var _i = 0, _a = Object.keys(sequential); _i < _a.length; _i++) {
        var key = _a[_i];
        sequentialColors.push(new InterpolatingColorFunction(key, 'sequential', sequential[key]));
    }
    for (var _b = 0, _c = Object.keys(divergent); _b < _c.length; _b++) {
        var key = _c[_b];
        divergentColors.push(new InterpolatingColorFunction(key, 'divergent', divergent[key]));
    }
    for (var _d = 0, sequentialColors_1 = sequentialColors; _d < sequentialColors_1.length; _d++) {
        var col = sequentialColors_1[_d];
        lookupInterpolatingColor.set(col.name, col);
    }
    for (var _e = 0, divergentColors_1 = divergentColors; _e < divergentColors_1.length; _e++) {
        var col = divergentColors_1[_e];
        lookupInterpolatingColor.set(col.name, col);
    }
}
export function createColorMappingFunction(dump) {
    if (!dump) {
        return DEFAULT_COLOR_FUNCTION;
    }
    if (typeof dump === 'string') {
        var s = lookupInterpolatingColor.get(dump);
        if (s) {
            return s;
        }
        return asColorFunction(dump);
    }
    if (typeof dump === 'function') {
        return new InterpolatingColorFunction('custom', 'sequential', dump);
    }
    if (dump.base && dump.steps) {
        return new QuantizedColorFunction(createColorMappingFunction(dump.base), dump.steps);
    }
    if (Array.isArray(dump)) {
        return new CustomColorMappingFunction(dump);
    }
    return DEFAULT_COLOR_FUNCTION;
}
export function restoreColorMapping(desc) {
    if (desc.colorMapping) {
        return createColorMappingFunction(desc.colorMapping);
    }
    if (desc.color) {
        console.warn('The property `color` in the column description is deprecated and will not work in an upcoming LineUp release. Use the property `colorMapping` instead.');
        return createColorMappingFunction(desc.color);
    }
    return DEFAULT_COLOR_FUNCTION;
}
//# sourceMappingURL=ColorMappingFunction.js.map