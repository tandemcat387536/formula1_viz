import 'reflect-metadata';
import Column from './Column';
var supportType = Symbol.for('SupportType');
var category = Symbol.for('Category');
export function SupportType() {
    return Reflect.metadata(supportType, true);
}
export function SortByDefault(order) {
    if (order === void 0) { order = 'ascending'; }
    if (order === 'descending') {
        return Reflect.metadata(Symbol.for('sortDescendingByDefault'), true);
    }
    return function (d) { return d; };
}
export function isSortingAscByDefault(col) {
    var clazz = col.constructor;
    return !Reflect.hasMetadata(Symbol.for('sortDescendingByDefault'), clazz);
}
var Categories = (function () {
    function Categories() {
        this.string = { label: 'label', order: 1, name: 'string', featureLevel: 'basic' };
        this.categorical = { label: 'categorical', order: 2, name: 'categorical', featureLevel: 'basic' };
        this.number = { label: 'numerical', order: 3, name: 'number', featureLevel: 'basic' };
        this.date = { label: 'date', order: 4, name: 'date', featureLevel: 'basic' };
        this.array = { label: 'matrix', order: 5, name: 'array', featureLevel: 'advanced' };
        this.map = { label: 'map', order: 6, name: 'map', featureLevel: 'advanced' };
        this.composite = { label: 'combined', order: 7, name: 'composite', featureLevel: 'advanced' };
        this.support = { label: 'support', order: 8, name: 'support', featureLevel: 'advanced' };
        this.other = { label: 'others', order: 9, name: 'other', featureLevel: 'advanced' };
    }
    return Categories;
}());
export { Categories };
export var categories = new Categories();
export function Category(cat) {
    return Reflect.metadata(category, cat);
}
export function toolbar() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    return Reflect.metadata(Symbol.for('toolbarIcon'), keys);
}
export function dialogAddons(key) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    return Reflect.metadata(Symbol.for("toolbarDialogAddon" + key), keys);
}
var cache = new Map();
export function isSupportType(col) {
    var clazz = col.constructor;
    return Reflect.hasMetadata(supportType, clazz);
}
export function categoryOf(col) {
    var cat = Reflect.getMetadata(category, col instanceof Column ? Object.getPrototypeOf(col).constructor : col) || 'other';
    return categories[cat] || categories.other;
}
export function categoryOfDesc(col, models) {
    var type = typeof col === 'string' ? col : col.type;
    var clazz = models[type];
    return clazz ? categoryOf(clazz) : categories.other;
}
export function getAllToolbarActions(col) {
    if (cache.has(col.desc.type)) {
        return cache.get(col.desc.type);
    }
    var actions = [];
    var obj = col;
    var toolbarIcon = Symbol.for('toolbarIcon');
    do {
        var m = Reflect.getOwnMetadata(toolbarIcon, obj.constructor);
        if (m) {
            actions.push.apply(actions, m);
        }
        obj = Object.getPrototypeOf(obj);
    } while (obj);
    cache.set(col.desc.type, actions);
    return actions;
}
export function getAllToolbarDialogAddons(col, key) {
    var cacheKey = col.desc.type + "@" + key;
    if (cache.has(cacheKey)) {
        return cache.get(cacheKey);
    }
    var actions = [];
    var obj = col;
    var symbol = Symbol.for("toolbarDialogAddon" + key);
    do {
        var m = Reflect.getOwnMetadata(symbol, obj.constructor);
        if (m) {
            actions.push.apply(actions, m);
        }
        obj = Object.getPrototypeOf(obj);
    } while (obj);
    cache.set(cacheKey, actions);
    return actions;
}
//# sourceMappingURL=annotations.js.map