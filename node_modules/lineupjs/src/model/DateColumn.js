import { __decorate, __extends } from "tslib";
import { timeFormat, timeParse } from 'd3-time-format';
import { Category, toolbar, dialogAddons } from './annotations';
import { FIRST_IS_MISSING, isMissingValue, missingGroup, isUnknown } from './missing';
import ValueColumn from './ValueColumn';
import Column from './Column';
import { noDateFilter, isDateIncluded, isDummyDateFilter, isEqualDateFilter, restoreDateFilter, toDateGroup, isDefaultDateGrouper, defaultDateGrouper } from './IDateColumn';
import { median } from 'd3-array';
import { defaultGroup } from './Group';
import { equal } from '../internal/utils';
import { numberCompare } from './INumberColumn';
var DateColumn = (function (_super) {
    __extends(DateColumn, _super);
    function DateColumn(id, desc) {
        var _this = _super.call(this, id, desc) || this;
        _this.currentFilter = noDateFilter();
        _this.currentGrouper = defaultDateGrouper();
        _this.format = timeFormat(desc.dateFormat || '%x');
        _this.parse = desc.dateParse ? timeParse(desc.dateParse) : timeParse(desc.dateFormat || '%x');
        return _this;
    }
    DateColumn_1 = DateColumn;
    DateColumn.prototype.dump = function (toDescRef) {
        var r = _super.prototype.dump.call(this, toDescRef);
        r.filter = isDummyDateFilter(this.currentFilter) ? null : this.currentFilter;
        if (this.currentGrouper && !isDefaultDateGrouper(this.currentGrouper)) {
            r.grouper = this.currentGrouper;
        }
        return r;
    };
    DateColumn.prototype.restore = function (dump, factory) {
        _super.prototype.restore.call(this, dump, factory);
        if (dump.filter) {
            this.currentFilter = restoreDateFilter(dump.filter);
        }
        if (dump.grouper) {
            this.currentGrouper = dump.grouper;
        }
    };
    DateColumn.prototype.createEventList = function () {
        return _super.prototype.createEventList.call(this).concat([DateColumn_1.EVENT_FILTER_CHANGED, DateColumn_1.EVENT_GROUPING_CHANGED]);
    };
    DateColumn.prototype.on = function (type, listener) {
        return _super.prototype.on.call(this, type, listener);
    };
    DateColumn.prototype.getValue = function (row) {
        return this.getDate(row);
    };
    DateColumn.prototype.getDate = function (row) {
        var v = _super.prototype.getValue.call(this, row);
        if (isMissingValue(v)) {
            return null;
        }
        if (v instanceof Date) {
            return v;
        }
        return this.parse(String(v));
    };
    DateColumn.prototype.getLabel = function (row) {
        var v = this.getValue(row);
        if (!(v instanceof Date)) {
            return '';
        }
        return this.format(v);
    };
    DateColumn.prototype.isFiltered = function () {
        return !isDummyDateFilter(this.currentFilter);
    };
    DateColumn.prototype.getFilter = function () {
        return Object.assign({}, this.currentFilter);
    };
    DateColumn.prototype.setFilter = function (value) {
        if (value === void 0) { value = { min: -Infinity, max: +Infinity, filterMissing: false }; }
        if (isEqualDateFilter(value, this.currentFilter)) {
            return;
        }
        var bak = this.getFilter();
        this.currentFilter.min = isUnknown(value.min) ? -Infinity : value.min;
        this.currentFilter.max = isUnknown(value.max) ? Infinity : value.max;
        this.currentFilter.filterMissing = value.filterMissing;
        this.fire([DateColumn_1.EVENT_FILTER_CHANGED, Column.EVENT_DIRTY_VALUES, Column.EVENT_DIRTY], bak, this.getFilter());
    };
    DateColumn.prototype.filter = function (row) {
        return isDateIncluded(this.currentFilter, this.getDate(row));
    };
    DateColumn.prototype.compare = function (a, b) {
        var av = this.getDate(a);
        var bv = this.getDate(b);
        if (av === bv) {
            return 0;
        }
        if (!(av instanceof Date)) {
            return (bv instanceof Date) ? FIRST_IS_MISSING : 0;
        }
        if (!(bv instanceof Date)) {
            return FIRST_IS_MISSING * -1;
        }
        return av.getTime() - bv.getTime();
    };
    DateColumn.prototype.getDateGrouper = function () {
        return Object.assign({}, this.currentGrouper);
    };
    DateColumn.prototype.setDateGrouper = function (value) {
        if (equal(this.currentGrouper, value)) {
            return;
        }
        var bak = this.getDateGrouper();
        this.currentGrouper = Object.assign({}, value);
        this.fire([DateColumn_1.EVENT_GROUPING_CHANGED, Column.EVENT_DIRTY_VALUES, Column.EVENT_DIRTY], bak, value);
    };
    DateColumn.prototype.group = function (row) {
        var v = this.getDate(row);
        if (!v || !(v instanceof Date)) {
            return missingGroup;
        }
        if (!this.currentGrouper) {
            return defaultGroup;
        }
        var g = toDateGroup(this.currentGrouper, v);
        return {
            name: g.name,
            color: Column.DEFAULT_COLOR
        };
    };
    DateColumn.prototype.groupCompare = function (a, b) {
        var av = choose(a.rows, this.currentGrouper, this).value;
        var bv = choose(b.rows, this.currentGrouper, this).value;
        return numberCompare(av, bv, false, false);
    };
    var DateColumn_1;
    DateColumn.EVENT_FILTER_CHANGED = 'filterChanged';
    DateColumn.EVENT_GROUPING_CHANGED = 'groupingChanged';
    DateColumn = DateColumn_1 = __decorate([
        toolbar('groupBy', 'sortGroupBy', 'filterDate'),
        dialogAddons('group', 'groupDate'),
        Category('date')
    ], DateColumn);
    return DateColumn;
}(ValueColumn));
export default DateColumn;
export function choose(rows, grouper, col) {
    var vs = rows.map(function (d) { return col.getDate(d); }).filter(function (d) { return d instanceof Date; });
    if (vs.length === 0) {
        return { value: null, name: '' };
    }
    var median = trueMedian(vs, function (d) { return d.getTime(); });
    if (!grouper) {
        return { value: median, name: (new Date(median)).toString() };
    }
    return toDateGroup(grouper, new Date(median));
}
function trueMedian(dates, acc) {
    if (dates.length % 2 === 1) {
        return median(dates, acc);
    }
    var s = dates.slice().sort(function (a, b) { return a.getTime() - b.getTime(); });
    return s[Math.floor(s.length / 2)].getTime();
}
//# sourceMappingURL=DateColumn.js.map