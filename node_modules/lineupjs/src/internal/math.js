import { __decorate } from "tslib";
import { ascending, histogram, mean, median, quantile } from 'd3-array';
import { isMissingValue } from '../model';
export function getNumberOfBins(length) {
    return Math.ceil(Math.log(length) / Math.LN2) + 1;
}
var LazyBoxPlotData = (function () {
    function LazyBoxPlotData(values, scale, histGen) {
        this.scale = scale;
        this.histGen = histGen;
        this.values = values.filter(function (d) { return !isMissingValue(d); });
        this.missing = values.length - this.values.length;
    }
    Object.defineProperty(LazyBoxPlotData.prototype, "count", {
        get: function () {
            return this.values.length + this.missing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "sorted", {
        get: function () {
            return this.values.slice().sort(ascending);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "sortedMapped", {
        get: function () {
            var _this = this;
            return this.scale ? this.sorted.map(function (v) { return _this.scale.apply(v); }) : this.sorted;
        },
        enumerable: true,
        configurable: true
    });
    LazyBoxPlotData.prototype.map = function (v) {
        return this.scale && v != null ? this.scale.apply(v) : v;
    };
    Object.defineProperty(LazyBoxPlotData.prototype, "hist", {
        get: function () {
            if (!this.histGen) {
                return [];
            }
            return this.histGen(this.values);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "maxBin", {
        get: function () {
            return Math.max.apply(Math, this.hist.map(function (d) { return d.length; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "min", {
        get: function () {
            return this.map(Math.min.apply(Math, this.values));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "max", {
        get: function () {
            return this.map(Math.max.apply(Math, this.values));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "median", {
        get: function () {
            return this.map(median(this.sorted));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "q1", {
        get: function () {
            return this.map(quantile(this.sorted, 0.25));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "q3", {
        get: function () {
            return this.map(quantile(this.sorted, 0.75));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "mean", {
        get: function () {
            return this.map(mean(this.values));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "whiskerLow", {
        get: function () {
            var q1 = this.q1;
            var q3 = this.q3;
            var iqr = q3 - q1;
            var left = q1 - 1.5 * iqr;
            var whiskerLow = left;
            for (var _i = 0, _a = this.sortedMapped; _i < _a.length; _i++) {
                var v = _a[_i];
                if (left < v) {
                    whiskerLow = v;
                    break;
                }
            }
            return whiskerLow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "whiskerHigh", {
        get: function () {
            var q1 = this.q1;
            var q3 = this.q3;
            var iqr = q3 - q1;
            var right = q3 + 1.5 * iqr;
            var whiskerHigh = right;
            for (var _i = 0, _a = this.sortedMapped.slice().reverse(); _i < _a.length; _i++) {
                var v = _a[_i];
                if (v < right) {
                    whiskerHigh = v;
                    break;
                }
            }
            return whiskerHigh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyBoxPlotData.prototype, "outlier", {
        get: function () {
            var left = this.whiskerLow;
            var right = this.whiskerHigh;
            return this.sortedMapped.filter(function (v) { return (v < left || v > right) && !isMissingValue(v); });
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "sorted", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "sortedMapped", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "hist", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "maxBin", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "min", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "max", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "median", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "q1", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "q3", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "mean", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "whiskerLow", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "whiskerHigh", null);
    __decorate([
        cached()
    ], LazyBoxPlotData.prototype, "outlier", null);
    return LazyBoxPlotData;
}());
export { LazyBoxPlotData };
function cached() {
    return function (_target, propertyKey, descriptor) {
        var getter = descriptor.get;
        var cacheKey = "__" + propertyKey;
        descriptor.get = function () {
            if (this.hasOwnProperty(cacheKey)) {
                return this[cacheKey];
            }
            var value = getter.call(this);
            this[cacheKey] = value;
            return value;
        };
        return descriptor;
    };
}
export function computeStats(arr, acc, missing, range, bins) {
    if (arr.length === 0) {
        return {
            min: NaN,
            max: NaN,
            mean: NaN,
            q1: NaN,
            q3: NaN,
            outlier: [],
            median: NaN,
            count: 0,
            maxBin: 0,
            hist: [],
            missing: 0
        };
    }
    var hist = histogram();
    if (range) {
        hist.domain(range);
    }
    if (bins) {
        hist.thresholds(bins);
    }
    else {
        hist.thresholds(getNumberOfBins(arr.length));
    }
    var values = arr.map(function (v) { return missing(v) ? NaN : acc(v); });
    return new LazyBoxPlotData(values, undefined, hist);
}
export function computeHist(arr, acc, categories) {
    var m = new Map();
    var missingCount = 0;
    categories.forEach(function (cat) { return m.set(cat.name, 0); });
    arr.forEach(function (a) {
        var v = acc(a);
        if (v == null) {
            missingCount += 1;
            return;
        }
        m.set(v.name, (m.get(v.name) || 0) + 1);
    });
    var entries = [];
    m.forEach(function (v, k) { return entries.push({ cat: k, y: v }); });
    return {
        maxBin: Math.max.apply(Math, entries.map(function (d) { return d.y; })),
        hist: entries,
        missing: missingCount
    };
}
export function round(v, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision === 0) {
        return Math.round(v);
    }
    var scale = Math.pow(10, precision);
    return Math.round(v * scale) / scale;
}
export function similar(a, b, delta) {
    if (delta === void 0) { delta = 0.5; }
    if (a === b) {
        return true;
    }
    return Math.abs(a - b) < delta;
}
//# sourceMappingURL=math.js.map