import { __spreadArrays } from "tslib";
export function hasDnDType(e) {
    var typesToCheck = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        typesToCheck[_i - 1] = arguments[_i];
    }
    console.assert(e.dataTransfer != null);
    var available = e.dataTransfer.types;
    if (typeof available.indexOf === 'function') {
        return typesToCheck.some(function (type) { return available.indexOf(type) >= 0; });
    }
    if (typeof available.includes === 'function') {
        return typesToCheck.some(function (type) { return available.includes(type); });
    }
    if (typeof available.contains === 'function') {
        return typesToCheck.some(function (type) { return available.contains(type); });
    }
    return false;
}
var dndTransferStorage = new Map();
function isEdgeDnD(e) {
    return dndTransferStorage.size > 0 && hasDnDType(e, 'text/plain');
}
export function copyDnD(e) {
    console.assert(e.dataTransfer != null);
    var dT = e.dataTransfer;
    return Boolean((e.ctrlKey && dT.effectAllowed.match(/copy/gi)) || (!dT.effectAllowed.match(/move/gi)));
}
export function updateDropEffect(e) {
    console.assert(e.dataTransfer != null);
    var dT = e.dataTransfer;
    if (copyDnD(e)) {
        dT.dropEffect = 'copy';
    }
    else {
        dT.dropEffect = 'move';
    }
}
var idCounter = 0;
export function dragAble(node, onDragStart, stopPropagation) {
    if (stopPropagation === void 0) { stopPropagation = false; }
    var id = ++idCounter;
    node.draggable = true;
    node.addEventListener('dragstart', function (e) {
        node.classList.add('lu-dragging');
        var payload = onDragStart();
        console.assert(e.dataTransfer != null);
        var dT = e.dataTransfer;
        dT.effectAllowed = payload.effectAllowed;
        if (stopPropagation) {
            e.stopPropagation();
        }
        var keys = Object.keys(payload.data);
        var allSucceded = keys.every(function (k) {
            try {
                dT.setData(k, payload.data[k]);
                return true;
            }
            catch (e) {
                return false;
            }
        });
        if (allSucceded) {
            return;
        }
        var text = payload.data['text/plain'] || '';
        dT.setData('text/plain', "" + id + (text ? ": " + text : ''));
        dndTransferStorage.set(id, payload.data);
    });
    node.addEventListener('dragend', function (e) {
        node.classList.remove('lu-dragging');
        if (stopPropagation) {
            e.stopPropagation();
        }
        if (dndTransferStorage.size > 0) {
            dndTransferStorage.delete(id);
        }
        var over = node.ownerDocument.querySelector('.lu-dragover');
        if (over) {
            over.classList.remove('lu-dragover');
        }
    });
}
export function dropAble(node, mimeTypes, onDrop, onDragOver, stopPropagation) {
    if (onDragOver === void 0) { onDragOver = null; }
    if (stopPropagation === void 0) { stopPropagation = false; }
    node.addEventListener('dragenter', function (e) {
        if (!node.classList.contains('lu-dragging') && (hasDnDType.apply(void 0, __spreadArrays([e], mimeTypes)) || isEdgeDnD(e))) {
            node.classList.add('lu-dragover');
            if (stopPropagation) {
                e.stopPropagation();
            }
            return false;
        }
        node.classList.remove('lu-dragover');
        return;
    });
    node.addEventListener('dragover', function (e) {
        if (!node.classList.contains('lu-dragging') && (hasDnDType.apply(void 0, __spreadArrays([e], mimeTypes)) || isEdgeDnD(e))) {
            e.preventDefault();
            updateDropEffect(e);
            node.classList.add('lu-dragover');
            if (stopPropagation) {
                e.stopPropagation();
            }
            if (onDragOver) {
                onDragOver(e);
            }
            return false;
        }
        return;
    });
    node.addEventListener('dragleave', function (evt) {
        evt.target.classList.remove('lu-dragover');
    });
    node.addEventListener('drop', function (e) {
        e.preventDefault();
        if (stopPropagation) {
            e.stopPropagation();
        }
        updateDropEffect(e);
        console.assert(e.dataTransfer != null);
        var dT = e.dataTransfer;
        var effect = dT.dropEffect;
        node.classList.remove('lu-dragover');
        if (isEdgeDnD(e)) {
            var base = dT.getData('text/plain');
            var id = parseInt(base.indexOf(':') >= 0 ? base.substring(0, base.indexOf(':')) : base, 10);
            if (dndTransferStorage.has(id)) {
                var data = dndTransferStorage.get(id);
                dndTransferStorage.delete(id);
                return !onDrop({ effect: effect, data: data }, e);
            }
            return;
        }
        if (hasDnDType.apply(void 0, __spreadArrays([e], mimeTypes))) {
            var data_1 = {};
            mimeTypes.forEach(function (mime) {
                var value = dT.getData(mime);
                if (value !== '') {
                    data_1[mime] = value;
                }
            });
            return !onDrop({ effect: effect, data: data_1 }, e);
        }
        return;
    });
}
//# sourceMappingURL=dnd.js.map