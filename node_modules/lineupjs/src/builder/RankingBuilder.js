import { __spreadArrays } from "tslib";
import { createAggregateDesc, createGroupDesc, createImpositionBoxPlotDesc, createImpositionDesc, createImpositionsDesc, createNestedDesc, createRankDesc, createReduceDesc, createScriptDesc, createSelectionDesc, createStackDesc } from '../model';
var RankingBuilder = (function () {
    function RankingBuilder() {
        this.columns = [];
        this.sort = [];
        this.groups = [];
    }
    RankingBuilder.prototype.sortBy = function (column, asc) {
        if (asc === void 0) { asc = true; }
        if (column.includes(':')) {
            var index = column.indexOf(':');
            asc = column.slice(index + 1);
            column = column.slice(0, index);
        }
        this.sort.push({ column: column, asc: asc === true || String(asc)[0] === 'a' });
        return this;
    };
    RankingBuilder.prototype.groupBy = function () {
        var _a;
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i] = arguments[_i];
        }
        (_a = this.groups).push.apply(_a, columns);
        return this;
    };
    RankingBuilder.prototype.column = function (column) {
        if (typeof column === 'string') {
            switch (column) {
                case '_aggregate':
                    return this.aggregate();
                case '_selection':
                    return this.selection();
                case '_group':
                    return this.group();
                case '_rank':
                    return this.rank();
                case '_*':
                    return this.supportTypes();
                case '*':
                    return this.allColumns();
            }
            this.columns.push(column);
            return this;
        }
        var label = column.label || null;
        switch (column.type) {
            case 'impose':
                return this.impose(label, column.column, column.categoricalColumn);
            case 'min':
            case 'max':
            case 'median':
            case 'mean':
                console.assert(column.columns.length >= 2);
                return this.reduce.apply(this, __spreadArrays([label, column.type, column.columns[0], column.columns[1]], column.columns.slice(2)));
            case 'nested':
                console.assert(column.columns.length >= 1);
                return this.nested.apply(this, __spreadArrays([label, column.columns[0]], column.columns.slice(1)));
            case 'script':
                console.assert(column.columns.length >= 2);
                return this.scripted.apply(this, __spreadArrays([label, column.code, column.columns[0], column.columns[1]], column.columns.slice(2)));
            case 'weightedSum':
                console.assert(column.columns.length >= 2);
                console.assert(column.columns.length === column.weights.length);
                var mixed_1 = [];
                column.columns.slice(2).forEach(function (c, i) {
                    mixed_1.push(c);
                    mixed_1.push(column.weights[i + 2]);
                });
                return this.weightedSum.apply(this, __spreadArrays([label, column.columns[0], column.weights[0], column.columns[1], column.weights[1]], mixed_1));
        }
        console.error('invalid column type: ', column);
        return this;
    };
    RankingBuilder.prototype.impose = function (label, numberColumn, categoricalColumn) {
        this.columns.push({
            desc: function (data) {
                var base = data.getColumns().find(function (d) { return d.label === numberColumn || d.column === numberColumn; });
                switch (base ? base.type : '') {
                    case 'boxplot':
                        return createImpositionBoxPlotDesc(label ? label : undefined);
                    case 'numbers':
                        return createImpositionsDesc(label ? label : undefined);
                    default:
                        return createImpositionDesc(label ? label : undefined);
                }
            },
            columns: [numberColumn, categoricalColumn]
        });
        return this;
    };
    RankingBuilder.prototype.nested = function (label, column) {
        var columns = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            columns[_i - 2] = arguments[_i];
        }
        this.columns.push({
            desc: createNestedDesc(label ? label : undefined),
            columns: [column].concat(columns)
        });
        return this;
    };
    RankingBuilder.prototype.weightedSum = function (label, numberColumn1, weight1, numberColumn2, weight2) {
        var numberColumnAndWeights = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            numberColumnAndWeights[_i - 5] = arguments[_i];
        }
        var weights = [weight1, weight2].concat(numberColumnAndWeights.filter(function (_, i) { return i % 2 === 1; }));
        this.columns.push({
            desc: createStackDesc(label ? label : undefined),
            columns: [numberColumn1, numberColumn2].concat(numberColumnAndWeights.filter(function (_, i) { return i % 2 === 0; })),
            post: function (col) {
                col.setWeights(weights);
            }
        });
        return this;
    };
    RankingBuilder.prototype.reduce = function (label, operation, numberColumn1, numberColumn2) {
        var numberColumns = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            numberColumns[_i - 4] = arguments[_i];
        }
        this.columns.push({
            desc: createReduceDesc(label ? label : undefined),
            columns: [numberColumn1, numberColumn2].concat(numberColumns),
            post: function (col) {
                col.setReduce(operation);
            }
        });
        return this;
    };
    RankingBuilder.prototype.scripted = function (label, code, numberColumn1, numberColumn2) {
        var numberColumns = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            numberColumns[_i - 4] = arguments[_i];
        }
        this.columns.push({
            desc: createScriptDesc(label ? label : undefined),
            columns: [numberColumn1, numberColumn2].concat(numberColumns),
            post: function (col) {
                col.setScript(code);
            }
        });
        return this;
    };
    RankingBuilder.prototype.selection = function () {
        this.columns.push({
            desc: createSelectionDesc(),
            columns: []
        });
        return this;
    };
    RankingBuilder.prototype.group = function () {
        this.columns.push({
            desc: createGroupDesc(),
            columns: []
        });
        return this;
    };
    RankingBuilder.prototype.aggregate = function () {
        this.columns.push({
            desc: createAggregateDesc(),
            columns: []
        });
        return this;
    };
    RankingBuilder.prototype.rank = function () {
        this.columns.push({
            desc: createRankDesc(),
            columns: []
        });
        return this;
    };
    RankingBuilder.prototype.supportTypes = function () {
        return this.aggregate().rank().selection();
    };
    RankingBuilder.prototype.allColumns = function () {
        this.columns.push(RankingBuilder.ALL_MAGIC_FLAG);
        return this;
    };
    RankingBuilder.prototype.build = function (data) {
        var r = data.pushRanking();
        var cols = data.getColumns();
        var findDesc = function (c) { return cols.find(function (d) { return d.label === c || d.column === c; }); };
        var addColumn = function (c) {
            var desc = findDesc(c);
            if (desc) {
                return data.push(r, desc) != null;
            }
            console.warn('invalid column: ', c);
            return false;
        };
        this.columns.forEach(function (c) {
            if (c === RankingBuilder.ALL_MAGIC_FLAG) {
                cols.forEach(function (col) { return data.push(r, col); });
                return;
            }
            if (typeof c === 'string') {
                addColumn(c);
                return;
            }
            var col = data.create(typeof c.desc === 'function' ? c.desc(data) : c.desc);
            r.push(col);
            c.columns.forEach(function (ci) {
                var d = findDesc(ci);
                var child = d ? data.create(d) : null;
                if (!child) {
                    console.warn('invalid column: ', ci);
                    return;
                }
                col.push(child);
            });
            if (c.post) {
                c.post(col);
            }
        });
        var children = r.children;
        {
            var groups_1 = [];
            this.groups.forEach(function (column) {
                var col = children.find(function (d) { return d.desc.label === column || d.desc.column === column; });
                if (col) {
                    groups_1.push(col);
                    return;
                }
                var desc = findDesc(column);
                if (desc && data.push(r, desc)) {
                    return;
                }
                console.warn('invalid group criteria column: ', column);
            });
            if (groups_1.length > 0) {
                r.setGroupCriteria(groups_1);
            }
        }
        {
            var sorts_1 = [];
            this.sort.forEach(function (_a) {
                var column = _a.column, asc = _a.asc;
                var col = children.find(function (d) { return d.desc.label === column || d.desc.column === column; });
                if (col) {
                    sorts_1.push({ col: col, asc: asc });
                    return;
                }
                var desc = findDesc(column);
                if (desc && data.push(r, desc)) {
                    return;
                }
                console.warn('invalid sort criteria column: ', column);
            });
            if (sorts_1.length > 0) {
                r.setSortCriteria(sorts_1);
            }
        }
        return r;
    };
    RankingBuilder.ALL_MAGIC_FLAG = '*';
    return RankingBuilder;
}());
export default RankingBuilder;
export function buildRanking() {
    return new RankingBuilder();
}
//# sourceMappingURL=RankingBuilder.js.map