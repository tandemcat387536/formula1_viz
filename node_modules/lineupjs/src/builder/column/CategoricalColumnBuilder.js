import { __extends } from "tslib";
import ColumnBuilder from './ColumnBuilder';
import { cleanCategories } from '../../provider/utils';
import { resolveValue } from '../../internal/accessor';
var CategoricalColumnBuilder = (function (_super) {
    __extends(CategoricalColumnBuilder, _super);
    function CategoricalColumnBuilder(column) {
        return _super.call(this, 'categorical', column) || this;
    }
    CategoricalColumnBuilder.prototype.asOrdinal = function () {
        this.desc.type = 'ordinal';
        return this;
    };
    CategoricalColumnBuilder.prototype.categories = function (categories) {
        this.desc.categories = categories;
        return this;
    };
    CategoricalColumnBuilder.prototype.missingCategory = function (missingCategory) {
        this.desc.missingCategory = missingCategory;
        return this;
    };
    CategoricalColumnBuilder.prototype.asSet = function (separator) {
        if (separator) {
            this.desc.separator = separator;
        }
        this.desc.type = 'set';
        return this;
    };
    CategoricalColumnBuilder.prototype.derive = function (data) {
        var _this = this;
        var categories = new Set();
        var isSet = this.desc.type === 'set';
        var separator = this.desc.separator || ';';
        var val = function (vi) {
            if (typeof vi === 'string' && vi !== '') {
                return vi;
            }
            if (vi != null && typeof vi.value === 'string' && vi.value !== '') {
                return vi.value;
            }
            return null;
        };
        data.forEach(function (d) {
            var v = resolveValue(d, _this.desc.column);
            if (Array.isArray(v)) {
                v.forEach(function (vi) { return categories.add(val(vi)); });
            }
            else if (v != null && v !== '') {
                var vs = isSet ? [v.toString()] : v.toString().split(separator);
                vs.forEach(function (vi) { return categories.add(val(vi)); });
            }
        });
        this.categories(cleanCategories(categories));
    };
    CategoricalColumnBuilder.prototype.build = function (data) {
        if (!this.desc.categories) {
            this.derive(data);
        }
        return _super.prototype.build.call(this, data);
    };
    return CategoricalColumnBuilder;
}(ColumnBuilder));
export default CategoricalColumnBuilder;
export function buildCategoricalColumn(column, categories) {
    var r = new CategoricalColumnBuilder(column);
    if (categories) {
        r.categories(categories);
    }
    return r;
}
//# sourceMappingURL=CategoricalColumnBuilder.js.map