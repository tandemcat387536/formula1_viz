import { __extends } from "tslib";
import { min, max } from 'd3-array';
import ColumnBuilder from './ColumnBuilder';
import { resolveValue } from '../../internal/accessor';
var NumberColumnBuilder = (function (_super) {
    __extends(NumberColumnBuilder, _super);
    function NumberColumnBuilder(column) {
        return _super.call(this, 'number', column) || this;
    }
    NumberColumnBuilder.prototype.mapping = function (type, domain, range) {
        if (type === 'linear') {
            this.desc.domain = domain;
            if (range) {
                this.desc.range = range;
            }
            return;
        }
        this.desc.map = {
            type: type, domain: domain, range: range || [0, 1]
        };
        return this;
    };
    NumberColumnBuilder.prototype.color = function (color) {
        return this.colorMapping(color);
    };
    NumberColumnBuilder.prototype.colorMapping = function (type) {
        this.desc.colorMapping = type;
        return this;
    };
    NumberColumnBuilder.prototype.scripted = function (code, domain) {
        this.desc.map = { domain: domain, code: code, type: 'script' };
        return this;
    };
    NumberColumnBuilder.prototype.asArray = function (labels, sort) {
        if (sort) {
            this.desc.sort = sort;
        }
        return _super.prototype.asArray.call(this, labels);
    };
    NumberColumnBuilder.prototype.asMap = function (sort) {
        if (sort) {
            this.desc.sort = sort;
        }
        return _super.prototype.asMap.call(this);
    };
    NumberColumnBuilder.prototype.asBoxPlot = function (sort) {
        if (sort) {
            this.desc.sort = sort;
        }
        this.desc.type = 'boxplot';
        return this;
    };
    NumberColumnBuilder.prototype.derive = function (data) {
        var col = this.desc.column;
        var asArray = function (v, extra) {
            var vs = [];
            (Array.isArray(v) ? v : [v]).forEach(function (vi) {
                if (typeof vi === 'number' && !isNaN(vi)) {
                    vs.push(vi);
                }
                if (vi != null && typeof vi.value === 'number' && !isNaN(vi.value)) {
                    vs.push(vi.value);
                }
                if (vi != null && typeof vi[extra] === 'number' && !isNaN(vi[extra])) {
                    vs.push(vi[extra]);
                }
            });
            return vs;
        };
        var minv = min(data, function (d) {
            var v = resolveValue(d, col);
            var vs = asArray(v, 'min');
            return vs.length === 0 ? Infinity : min(vs);
        });
        var maxv = max(data, function (d) {
            var v = resolveValue(d, col);
            var vs = asArray(v, 'max');
            return vs.length === 0 ? -Infinity : max(vs);
        });
        return [minv, maxv];
    };
    NumberColumnBuilder.prototype.build = function (data) {
        if (!this.desc.map && !this.desc.domain) {
            this.mapping('linear', this.derive(data));
        }
        else {
            var d = this.desc.domain || this.desc.map.domain;
            if (isNaN(d[0]) || isNaN(d[1])) {
                var ext = this.derive(data);
                if (isNaN(d[0])) {
                    d[0] = ext[0];
                }
                if (isNaN(d[1])) {
                    d[1] = ext[1];
                }
            }
        }
        return _super.prototype.build.call(this, data);
    };
    return NumberColumnBuilder;
}(ColumnBuilder));
export default NumberColumnBuilder;
export function buildNumberColumn(column, domain) {
    var r = new NumberColumnBuilder(column);
    if (domain) {
        r.mapping('linear', domain);
    }
    return r;
}
//# sourceMappingURL=NumberColumnBuilder.js.map