import { ICategoricalStatistics, IStatistics } from '../internal';
import AEventDispatcher from '../internal/AEventDispatcher';
import { Column, ICategoricalColumn, IColumnDesc, IDataRow, IGroup, INumberColumn, IOrderedGroup } from '../model';
import { dirty, dirtyHeader, dirtyValues } from '../model/Column';
import Ranking, { orderChanged, addColumn, removeColumn } from '../model/Ranking';
import { IExportOptions } from './utils';
import { IEventListener } from '../internal/AEventDispatcher';
export { IExportOptions } from './utils';
export interface IStatsBuilder {
    stats(col: INumberColumn): Promise<IStatistics> | IStatistics;
    hist(col: ICategoricalColumn): Promise<ICategoricalStatistics> | ICategoricalStatistics;
}
export interface IDataProviderOptions {
    columnTypes: {
        [columnType: string]: typeof Column;
    };
    multiSelection: boolean;
}
export interface IDataProvider extends AEventDispatcher {
    readonly columnTypes: {
        [columnType: string]: typeof Column;
    };
    getTotalNumberOfRows(): number;
    takeSnapshot(col: Column): void;
    selectAllOf(ranking: Ranking): void;
    getSelection(): number[];
    setSelection(dataIndices: number[]): void;
    toggleSelection(i: number, additional?: boolean): boolean;
    isSelected(i: number): boolean;
    removeRanking(ranking: Ranking): void;
    ensureOneRanking(): void;
    find(id: string): Column | null;
    clone(col: Column): Column;
    create(desc: IColumnDesc): Column | null;
    toDescRef(desc: IColumnDesc): any;
    fromDescRef(ref: any): IColumnDesc;
    mappingSample(col: Column): Promise<number[]> | number[];
    searchAndJump(search: string | RegExp, col: Column): void;
    getRankings(): Ranking[];
    getFirstRanking(): Ranking | null;
    getLastRanking(): Ranking;
    getColumns(): IColumnDesc[];
    isAggregated(ranking: Ranking, group: IGroup): boolean;
    aggregateAllOf(ranking: Ranking, aggregateAll: boolean): void;
}
export declare function selectionChanged(dataIndices: number[]): void;
export declare function addRanking(ranking: Ranking, index: number): void;
export declare function removeRanking(ranking: Ranking | null, index: number): void;
export declare function orderchanged(dataIndices: number[]): void;
export declare function addDesc(desc: IColumnDesc): void;
export declare function clearDesc(): void;
export declare function jumpToNearest(dataIndices: number[]): void;
export declare function aggregate(ranking: Ranking, group: IGroup | IGroup[], value: boolean): void;
declare abstract class ADataProvider extends AEventDispatcher implements IDataProvider {
    static readonly EVENT_SELECTION_CHANGED = "selectionChanged";
    static readonly EVENT_ADD_COLUMN = "addColumn";
    static readonly EVENT_REMOVE_COLUMN = "removeColumn";
    static readonly EVENT_ADD_RANKING = "addRanking";
    static readonly EVENT_REMOVE_RANKING = "removeRanking";
    static readonly EVENT_DIRTY = "dirty";
    static readonly EVENT_DIRTY_HEADER = "dirtyHeader";
    static readonly EVENT_DIRTY_VALUES = "dirtyValues";
    static readonly EVENT_ORDER_CHANGED = "orderChanged";
    static readonly EVENT_ADD_DESC = "addDesc";
    static readonly EVENT_CLEAR_DESC = "clearDesc";
    static readonly EVENT_JUMP_TO_NEAREST = "jumpToNearest";
    static readonly EVENT_GROUP_AGGREGATION_CHANGED = "aggregate";
    private rankings;
    private readonly selection;
    private aggregations;
    private uid;
    readonly columnTypes: {
        [columnType: string]: typeof Column;
    };
    protected readonly multiSelections: boolean;
    constructor(options?: Partial<IDataProviderOptions>);
    protected createEventList(): string[];
    on(type: typeof ADataProvider.EVENT_ADD_COLUMN, listener: typeof addColumn | null): this;
    on(type: typeof ADataProvider.EVENT_REMOVE_COLUMN, listener: typeof removeColumn | null): this;
    on(type: typeof ADataProvider.EVENT_ADD_RANKING, listener: typeof addRanking | null): this;
    on(type: typeof ADataProvider.EVENT_REMOVE_RANKING, listener: typeof removeRanking | null): this;
    on(type: typeof ADataProvider.EVENT_DIRTY, listener: typeof dirty | null): this;
    on(type: typeof ADataProvider.EVENT_DIRTY_HEADER, listener: typeof dirtyHeader | null): this;
    on(type: typeof ADataProvider.EVENT_DIRTY_VALUES, listener: typeof dirtyValues | null): this;
    on(type: typeof ADataProvider.EVENT_ORDER_CHANGED, listener: typeof orderChanged | null): this;
    on(type: typeof ADataProvider.EVENT_ADD_DESC, listener: typeof addDesc | null): this;
    on(type: typeof ADataProvider.EVENT_CLEAR_DESC, listener: typeof clearDesc | null): this;
    on(type: typeof ADataProvider.EVENT_JUMP_TO_NEAREST, listener: typeof jumpToNearest | null): this;
    on(type: typeof ADataProvider.EVENT_GROUP_AGGREGATION_CHANGED, listener: typeof aggregate | null): this;
    on(type: typeof ADataProvider.EVENT_SELECTION_CHANGED, listener: typeof selectionChanged | null): this;
    on(type: string | string[], listener: IEventListener | null): this;
    abstract getTotalNumberOfRows(): number;
    abstract getColumns(): IColumnDesc[];
    pushRanking(existing?: Ranking): Ranking;
    takeSnapshot(col: Column): Ranking;
    insertRanking(r: Ranking, index?: number): void;
    protected triggerReorder(ranking: Ranking): void;
    removeRanking(ranking: Ranking): boolean;
    clearRankings(): void;
    getRankings(): Ranking[];
    getFirstRanking(): Ranking;
    getLastRanking(): Ranking;
    ensureOneRanking(): void;
    cleanUpRanking(_ranking: Ranking): void;
    abstract cloneRanking(existing?: Ranking): Ranking;
    push(ranking: Ranking, desc: IColumnDesc): Column | null;
    insert(ranking: Ranking, index: number, desc: IColumnDesc): Column | null;
    private nextId;
    protected abstract rankAccessor(row: IDataRow, id: string, desc: IColumnDesc, ranking: Ranking): number;
    private fixDesc;
    create(desc: IColumnDesc): Column | null;
    clone(col: Column): Column;
    restoreColumn(dump: any): Column;
    find(idOrFilter: string | ((col: Column) => boolean)): Column | null;
    dump(): any;
    dumpColumn(col: Column): any;
    toDescRef(desc: any): any;
    fromDescRef(descRef: any): any;
    private createHelper;
    restoreRanking(dump: any): Ranking;
    restore(dump: any): void;
    abstract findDesc(ref: string): IColumnDesc | null;
    abstract deriveDefault(addSupporType?: boolean): Ranking;
    private deriveRanking;
    isAggregated(ranking: Ranking, group: IGroup): boolean;
    private unaggregateParents;
    setAggregated(ranking: Ranking, group: IGroup, value: boolean): void;
    aggregateAllOf(ranking: Ranking, aggregateAll: boolean): void;
    abstract sort(ranking: Ranking): Promise<IOrderedGroup[]> | IOrderedGroup[];
    abstract view(indices: number[]): Promise<any[]> | any[];
    abstract fetch(orders: number[][]): (Promise<IDataRow> | IDataRow)[][];
    abstract mappingSample(col: Column): Promise<number[]> | number[];
    abstract stats(indices: number[]): IStatsBuilder;
    isSelected(index: number): boolean;
    select(index: number): void;
    abstract searchAndJump(search: string | RegExp, col: Column): void;
    jumpToNearest(indices: number[]): void;
    selectAll(indices: number[]): void;
    selectAllOf(ranking: Ranking): void;
    setSelection(indices: number[]): void;
    toggleSelection(index: number, additional?: boolean): boolean;
    deselect(index: number): void;
    deselectAll(indices: number[]): void;
    selectedRows(): Promise<any[]> | any[];
    getSelection(): number[];
    clearSelection(): void;
    exportTable(ranking: Ranking, options?: Partial<IExportOptions>): Promise<string>;
}
export default ADataProvider;
