import { __extends } from "tslib";
import { round } from '../internal';
import { isMultiLevelColumn } from '../model';
import { medianIndex } from '../model/internal';
import { isNumberColumn } from '../model/INumberColumn';
import { COLUMN_PADDING } from '../styles';
import { AAggregatedGroupRenderer } from './AAggregatedGroupRenderer';
import { ERenderMode } from './interfaces';
import { renderMissingCanvas, renderMissingDOM } from './missing';
import { matchColumns } from './utils';
export function gridClass(column) {
    return "lu-stacked-" + column.id;
}
export function createFlatColumnData(col, context, stacked, mode, imposer) {
    var padding = COLUMN_PADDING;
    var offset = 0;
    var cols = col.children.map(function (d) {
        var shift = offset;
        var width = d.getWidth();
        offset += width;
        offset += (!stacked ? padding : 0);
        var renderer = mode === ERenderMode.CELL ? context.renderer(d, imposer) : null;
        var groupRenderer = mode === ERenderMode.GROUP ? context.groupRenderer(d, imposer) : null;
        var summaryRenderer = mode === ERenderMode.GROUP ? context.summaryRenderer(d, false, imposer) : null;
        var template = '';
        var rendererId = '';
        switch (mode) {
            case ERenderMode.CELL:
                template = renderer.template;
                rendererId = col.getRenderer();
                break;
            case ERenderMode.GROUP:
                template = groupRenderer.template;
                rendererId = col.getGroupRenderer();
                break;
            case ERenderMode.SUMMARY:
                template = summaryRenderer.template;
                rendererId = col.getSummaryRenderer();
                break;
        }
        template = template.replace(/^<([^ >]+)([ >])/, "<$1 data-column-id=\"" + d.id + "\" data-renderer=\"" + rendererId + "\"$2");
        return {
            column: d,
            shift: shift,
            width: width,
            template: template,
            rendererId: rendererId,
            renderer: renderer,
            groupRenderer: groupRenderer,
            summaryRenderer: summaryRenderer
        };
    });
    return { cols: cols, stacked: stacked, padding: padding };
}
var MultiLevelCellRenderer = (function (_super) {
    __extends(MultiLevelCellRenderer, _super);
    function MultiLevelCellRenderer(stacked) {
        if (stacked === void 0) { stacked = true; }
        var _this = _super.call(this) || this;
        _this.stacked = stacked;
        _this.title = _this.stacked ? 'Stacked Bar' : 'Nested';
        return _this;
    }
    MultiLevelCellRenderer.prototype.canRender = function (col, mode) {
        return isMultiLevelColumn(col) && mode !== ERenderMode.SUMMARY;
    };
    MultiLevelCellRenderer.prototype.create = function (col, context, _hist, imposer) {
        var _a = createFlatColumnData(col, context, this.stacked, ERenderMode.CELL, imposer), cols = _a.cols, stacked = _a.stacked, padding = _a.padding;
        var useGrid = context.option('useGridLayout', false);
        var width = context.colWidth(col);
        return {
            template: "<div class='" + (useGrid ? gridClass(col) : '') + (useGrid && !stacked ? ' lu-grid-space' : '') + "'>" + cols.map(function (d) { return d.template; }).join('') + "</div>",
            update: function (n, d, i, group) {
                if (renderMissingDOM(n, col, d)) {
                    return;
                }
                matchColumns(n, cols);
                var children = Array.from(n.children);
                var total = col.getWidth();
                var missingWeight = 0;
                cols.forEach(function (col, ci) {
                    var weight = col.column.getWidth() / total;
                    var cnode = children[ci];
                    cnode.style.transform = stacked ? "translate(-" + round((missingWeight / weight) * 100, 4) + "%,0)" : '';
                    if (!useGrid) {
                        cnode.style.width = round(weight * 100, 2) + "%";
                        cnode.style.marginRight = stacked ? null : padding + "px";
                    }
                    else {
                        cnode.style.gridColumnStart = (ci + 1).toString();
                    }
                    col.renderer.update(cnode, d, i, group);
                    if (stacked) {
                        missingWeight += (1 - col.column.getValue(d)) * weight;
                    }
                });
            },
            render: function (ctx, d, i, group) {
                if (renderMissingCanvas(ctx, col, d, width)) {
                    return;
                }
                var stackShift = 0;
                cols.forEach(function (col) {
                    var shift = col.shift - stackShift;
                    ctx.translate(shift, 0);
                    col.renderer.render(ctx, d, i, group);
                    ctx.translate(-shift, 0);
                    if (stacked) {
                        stackShift += col.width * (1 - col.column.getValue(d));
                    }
                });
            }
        };
    };
    MultiLevelCellRenderer.prototype.createGroup = function (col, context, hist, imposer) {
        if (this.stacked && isNumberColumn(col)) {
            return _super.prototype.createGroup.call(this, col, context, hist, imposer);
        }
        var _a = createFlatColumnData(col, context, false, ERenderMode.GROUP, imposer), cols = _a.cols, padding = _a.padding;
        var useGrid = context.option('useGridLayout', false);
        return {
            template: "<div class='" + (useGrid ? gridClass(col) : '') + (useGrid ? ' lu-grid-space' : '') + "'>" + cols.map(function (d) { return d.template; }).join('') + "</div>",
            update: function (n, group, rows) {
                matchColumns(n, cols);
                var children = Array.from(n.children);
                var total = col.getWidth();
                cols.forEach(function (col, ci) {
                    var weight = col.column.getWidth() / total;
                    var cnode = children[ci];
                    if (!useGrid) {
                        cnode.style.width = round(weight * 100, 2) + "%";
                        cnode.style.marginRight = padding + "px";
                    }
                    else {
                        cnode.style.gridColumnStart = (ci + 1).toString();
                    }
                    col.groupRenderer.update(cnode, group, rows);
                });
            }
        };
    };
    MultiLevelCellRenderer.prototype.aggregatedIndex = function (rows, col) {
        console.assert(isNumberColumn(col));
        return medianIndex(rows, col);
    };
    return MultiLevelCellRenderer;
}(AAggregatedGroupRenderer));
export default MultiLevelCellRenderer;
//# sourceMappingURL=MultiLevelCellRenderer.js.map