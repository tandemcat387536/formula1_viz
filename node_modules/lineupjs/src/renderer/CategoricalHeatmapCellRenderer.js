import { isSetColumn } from '../model/ICategoricalColumn';
import { CANVAS_HEIGHT } from '../styles';
import { renderMissingCanvas, renderMissingDOM } from './missing';
import { union } from './UpSetCellRenderer';
import { noop, wideEnough, forEachChild } from './utils';
var CategoricalHeatmapCellRenderer = (function () {
    function CategoricalHeatmapCellRenderer() {
        this.title = 'Heatmap';
    }
    CategoricalHeatmapCellRenderer.prototype.canRender = function (col) {
        return isSetColumn(col);
    };
    CategoricalHeatmapCellRenderer.createDOMContext = function (col) {
        var categories = col.categories;
        var templateRows = '';
        for (var _i = 0, categories_1 = categories; _i < categories_1.length; _i++) {
            var cat = categories_1[_i];
            templateRows += "<div title=\"" + cat.label + "\" style=\"background-color: " + cat.color + "\"></div>";
        }
        return {
            templateRow: templateRows,
            render: function (n, value) {
                forEachChild(n, function (d, i) {
                    var v = value[i];
                    d.style.visibility = v ? null : 'hidden';
                });
            }
        };
    };
    CategoricalHeatmapCellRenderer.prototype.create = function (col, context) {
        var _a = CategoricalHeatmapCellRenderer.createDOMContext(col), templateRow = _a.templateRow, render = _a.render;
        var width = context.colWidth(col);
        var cellDimension = width / col.dataLength;
        var cats = col.categories;
        return {
            template: "<div>" + templateRow + "</div>",
            update: function (n, d) {
                if (renderMissingDOM(n, col, d)) {
                    return;
                }
                render(n, col.getValues(d));
            },
            render: function (ctx, d) {
                if (renderMissingCanvas(ctx, col, d, width)) {
                    return;
                }
                var data = col.getValues(d);
                ctx.save();
                cats.forEach(function (d, j) {
                    if (!data[j]) {
                        return;
                    }
                    var posx = (j * cellDimension);
                    ctx.fillStyle = d.color;
                    ctx.fillRect(posx, 0, cellDimension, CANVAS_HEIGHT);
                });
                ctx.restore();
            }
        };
    };
    CategoricalHeatmapCellRenderer.prototype.createGroup = function (col) {
        var _a = CategoricalHeatmapCellRenderer.createDOMContext(col), templateRow = _a.templateRow, render = _a.render;
        return {
            template: "<div>" + templateRow + "</div>",
            update: function (n, _group, rows) {
                var value = union(col, rows);
                render(n, value);
            }
        };
    };
    CategoricalHeatmapCellRenderer.prototype.createSummary = function (col) {
        var categories = col.categories;
        var templateRows = '<div>';
        var labels = wideEnough(col);
        for (var _i = 0, categories_2 = categories; _i < categories_2.length; _i++) {
            var cat = categories_2[_i];
            templateRows += "<div title=\"" + cat.label + "\"" + (labels ? " data-title=\"" + cat.label + "\"" : '') + " style=\"background-color: " + cat.color + "\"></div>";
        }
        templateRows += '</div>';
        return {
            template: templateRows,
            update: noop
        };
    };
    return CategoricalHeatmapCellRenderer;
}());
export default CategoricalHeatmapCellRenderer;
//# sourceMappingURL=CategoricalHeatmapCellRenderer.js.map