import { range } from 'lineupengine';
import { isGroup } from '../model';
import { SLOPEGRAPH_WIDTH } from '../styles';
var ItemSlope = (function () {
    function ItemSlope(left, right, dataIndices) {
        this.left = left;
        this.right = right;
        this.dataIndices = dataIndices;
    }
    ItemSlope.prototype.isSelected = function (selection) {
        return this.dataIndices.length === 1 ? selection.has(this.dataIndices[0]) : this.dataIndices.some(function (s) { return selection.has(s); });
    };
    ItemSlope.prototype.update = function (path, width) {
        path.setAttribute('data-i', String(this.dataIndices[0]));
        path.setAttribute('class', 'lu-slope');
        path.setAttribute('d', "M0," + this.left + "L" + width + "," + this.right);
    };
    return ItemSlope;
}());
var GroupSlope = (function () {
    function GroupSlope(left, right, dataIndices) {
        this.left = left;
        this.right = right;
        this.dataIndices = dataIndices;
    }
    GroupSlope.prototype.isSelected = function (selection) {
        return this.dataIndices.some(function (s) { return selection.has(s); });
    };
    GroupSlope.prototype.update = function (path, width) {
        path.setAttribute('class', 'lu-group-slope');
        path.setAttribute('d', "M0," + this.left[0] + "L" + width + "," + this.right[0] + "L" + width + "," + this.right[1] + "L0," + this.left[1] + "Z");
    };
    return GroupSlope;
}());
export var EMode;
(function (EMode) {
    EMode["ITEM"] = "item";
    EMode["BAND"] = "band";
})(EMode || (EMode = {}));
var SlopeGraph = (function () {
    function SlopeGraph(header, body, id, ctx, options) {
        if (options === void 0) { options = {}; }
        this.header = header;
        this.body = body;
        this.id = id;
        this.ctx = ctx;
        this.leftSlopes = [];
        this.rightSlopes = [];
        this.pool = [];
        this.scrollListener = null;
        this.width = SLOPEGRAPH_WIDTH;
        this.height = 0;
        this.current = null;
        this._mode = EMode.ITEM;
        console.assert(header.ownerDocument != null);
        this.node = header.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'svg');
        this.node.innerHTML = "<g transform=\"translate(0,0)\"></g>";
        header.classList.add('lu-slopegraph-header');
        this._mode = options.mode === EMode.BAND ? EMode.BAND : EMode.ITEM;
        this.initHeader(header);
        body.classList.add('lu-slopegraph');
        this.body.style.height = "1px";
        body.appendChild(this.node);
    }
    SlopeGraph.prototype.init = function () {
        var _this = this;
        this.hide();
        var scroller = this.body.parentElement;
        var scroll = scroller.__le_scroller__;
        var old = scroll.asInfo();
        scroll.push('animation', this.scrollListener = function (act) {
            if (Math.abs(old.top - act.top) < 5) {
                return;
            }
            old = act;
            _this.onScrolledVertically(act.top, act.height);
        });
    };
    SlopeGraph.prototype.initHeader = function (header) {
        var _this = this;
        header.innerHTML = "<i title=\"Item\" class=\"" + (this._mode === EMode.ITEM ? 'active' : '') + "\"><span aria-hidden=\"true\">Item</span></i>\n        <i title=\"Band\" class=\"" + (this._mode === EMode.BAND ? 'active' : '') + "\"><span aria-hidden=\"true\">Band</span></i>";
        var icons = Array.from(header.children);
        icons.forEach(function (n, i) {
            n.onclick = function (evt) {
                evt.preventDefault();
                evt.stopPropagation();
                if (n.classList.contains('active')) {
                    return;
                }
                _this.mode = i === 0 ? EMode.ITEM : EMode.BAND;
                icons.forEach(function (d, j) { return d.classList.toggle('active', j === i); });
            };
        });
    };
    Object.defineProperty(SlopeGraph.prototype, "mode", {
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (value === this._mode) {
                return;
            }
            this._mode = value;
            if (this.current) {
                this.rebuild(this.current.left, this.current.leftContext, this.current.right, this.current.rightContext);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlopeGraph.prototype, "hidden", {
        get: function () {
            return this.header.classList.contains('loading');
        },
        set: function (value) {
            this.header.classList.toggle('loading', value);
            this.body.classList.toggle('loading', value);
        },
        enumerable: true,
        configurable: true
    });
    SlopeGraph.prototype.hide = function () {
        this.hidden = true;
    };
    SlopeGraph.prototype.show = function () {
        var was = this.hidden;
        this.hidden = false;
        if (was) {
            this.revalidate();
        }
    };
    SlopeGraph.prototype.destroy = function () {
        this.header.remove();
        if (this.scrollListener) {
            var scroll_1 = this.body.parentElement.__le_scroller__;
            scroll_1.remove(this.scrollListener);
        }
        this.body.remove();
    };
    SlopeGraph.prototype.rebuild = function (left, leftContext, right, rightContext) {
        this.current = { left: left, leftContext: leftContext, right: right, rightContext: rightContext };
        var lookup = this.prepareRightSlopes(right, rightContext);
        this.computeSlopes(left, leftContext, lookup);
        this.revalidate();
    };
    SlopeGraph.prototype.computeSlopes = function (left, leftContext, lookup) {
        var _this = this;
        var mode = this.mode;
        var fakeGroups = new Map();
        var createFakeGroup = function (first, group) {
            var count = 0;
            var height = 0;
            var rows = [];
            for (var i = first; i < left.length; ++i) {
                var item = left[i];
                if (isGroup(item) || item.group !== group) {
                    break;
                }
                count++;
                height += (leftContext.exceptionsLookup.get(i) || leftContext.defaultRowHeight);
                rows.push(item);
            }
            var padded = height - leftContext.padding(first + count - 1);
            var gr = Object.assign({
                rows: rows
            }, group);
            return { gr: gr, padded: padded, height: height };
        };
        var acc = 0;
        this.leftSlopes = left.map(function (r, i) {
            var height = (leftContext.exceptionsLookup.get(i) || leftContext.defaultRowHeight);
            var padded = height - 0;
            var slopes = [];
            var start = acc;
            acc += height;
            var offset = 0;
            var push = function (s, right, common, heightPerRow) {
                if (common === void 0) { common = 1; }
                if (heightPerRow === void 0) { heightPerRow = 0; }
                slopes.push(s);
                right.ref.forEach(function (r) { return _this.rightSlopes[r].push(s); });
                right.offset += common * right.heightPerRow;
                offset += common * heightPerRow;
            };
            var gr;
            if (isGroup(r)) {
                gr = r;
            }
            else {
                var item = r;
                var dataIndex = item.i;
                var right = lookup.get(dataIndex);
                if (!right) {
                    return slopes;
                }
                if (mode === EMode.ITEM) {
                    var s = new ItemSlope(start + padded / 2, right.start + right.offset + right.heightPerRow / 2, [dataIndex]);
                    push(s, right);
                    return slopes;
                }
                if (fakeGroups.has(item.group)) {
                    return fakeGroups.get(item.group);
                }
                var fakeGroup = createFakeGroup(i, item.group);
                gr = fakeGroup.gr;
                height = fakeGroup.height;
                padded = fakeGroup.padded;
                fakeGroups.set(item.group, slopes);
            }
            var free = new Set(gr.rows.map(function (d) { return d.i; }));
            var heightPerRow = padded / gr.rows.length;
            gr.rows.forEach(function (d) {
                if (!free.has(d.i)) {
                    return;
                }
                free.delete(d.i);
                var right = lookup.get(d.i);
                if (!right) {
                    return;
                }
                var intersection = right.rows.filter(function (r) { return free.delete(r); });
                intersection.push(d.i);
                var common = intersection.length;
                var s;
                if (common === 1) {
                    s = new ItemSlope(start + offset + heightPerRow / 2, right.start + right.offset + right.heightPerRow / 2, [d.i]);
                }
                else if (mode === EMode.ITEM) {
                    s = new ItemSlope(start + offset + heightPerRow * common / 2, right.start + right.offset + right.heightPerRow * common / 2, intersection);
                }
                else {
                    s = new GroupSlope([start + offset, start + offset + heightPerRow * common], [right.start + right.offset, right.start + right.offset + right.heightPerRow * common], intersection);
                }
                push(s, right, common, heightPerRow);
            });
            return slopes;
        });
    };
    SlopeGraph.prototype.prepareRightSlopes = function (right, rightContext) {
        var lookup = new Map();
        var mode = this.mode;
        var fakeGroups = new Map();
        var acc = 0;
        this.rightSlopes = right.map(function (r, i) {
            var height = (rightContext.exceptionsLookup.get(i) || rightContext.defaultRowHeight);
            var padded = height - 0;
            var start = acc;
            acc += height;
            var slopes = [];
            var base = {
                start: start,
                offset: 0,
                ref: [i]
            };
            if (isGroup(r)) {
                var p_1 = Object.assign(base, {
                    rows: r.rows.map(function (d) { return d.i; }),
                    heightPerRow: padded / r.rows.length,
                    group: r
                });
                r.rows.forEach(function (ri) { return lookup.set(ri.i, p_1); });
                return slopes;
            }
            var item = r;
            var dataIndex = r.i;
            var p = Object.assign(base, {
                rows: [dataIndex],
                heightPerRow: padded,
                group: item.group
            });
            if (mode === EMode.ITEM) {
                lookup.set(dataIndex, p);
                return slopes;
            }
            if (!fakeGroups.has(item.group)) {
                p.heightPerRow = height;
                fakeGroups.set(item.group, p);
            }
            else {
                p = fakeGroups.get(item.group);
                p.rows.push(dataIndex);
                p.ref.push(i);
            }
            lookup.set(dataIndex, p);
            return slopes;
        });
        return lookup;
    };
    SlopeGraph.prototype.revalidate = function () {
        if (!this.current || this.hidden) {
            return;
        }
        var p = this.body.parentElement;
        this.onScrolledVertically(p.scrollTop, p.clientHeight);
    };
    SlopeGraph.prototype.highlight = function (dataIndex) {
        var old = this.body.querySelector("[data-i].le-highlighted");
        if (old) {
            old.classList.remove('le-highlighted');
        }
        if (dataIndex < 0) {
            return;
        }
        var item = this.body.querySelector("[data-i=\"" + dataIndex + "\"]");
        if (item) {
            item.classList.add('le-highlighted');
        }
        return item != null;
    };
    SlopeGraph.prototype.onScrolledVertically = function (scrollTop, clientHeight) {
        if (!this.current) {
            return;
        }
        var _a = this.current, leftContext = _a.leftContext, rightContext = _a.rightContext;
        var left = range(scrollTop, clientHeight, leftContext.defaultRowHeight, leftContext.exceptions, leftContext.numberOfRows);
        var right = range(scrollTop, clientHeight, rightContext.defaultRowHeight, rightContext.exceptions, rightContext.numberOfRows);
        var start = Math.min(left.firstRowPos, right.firstRowPos);
        var end = Math.max(left.endPos, right.endPos);
        this.body.style.transform = "translate(0, " + start.toFixed(0) + "px)";
        this.body.style.height = (end - start).toFixed(0) + "px";
        (this.node.firstElementChild).setAttribute('transform', "translate(0,-" + start.toFixed(0) + ")");
        this.choose(left.first, left.last, right.first, right.last);
    };
    SlopeGraph.prototype.choose = function (leftVisibleFirst, leftVisibleLast, rightVisibleFirst, rightVisibleLast) {
        var slopes = new Set();
        for (var i = leftVisibleFirst; i <= leftVisibleLast; ++i) {
            this.leftSlopes[i].forEach(function (s) { return slopes.add(s); });
        }
        for (var i = rightVisibleFirst; i <= rightVisibleLast; ++i) {
            this.rightSlopes[i].forEach(function (s) { return slopes.add(s); });
        }
        this.render(slopes);
    };
    SlopeGraph.prototype.render = function (slopes) {
        var g = this.node.firstElementChild;
        var width = g.ownerSVGElement.getBoundingClientRect().width;
        var paths = this.matchLength(slopes, g);
        var p = this.ctx.provider;
        var selectionLookup = { has: function (dataIndex) { return p.isSelected(dataIndex); } };
        var i = 0;
        slopes.forEach(function (s) {
            var p = paths[i++];
            s.update(p, width);
            p.__data__ = s;
            var selected = s.isSelected(selectionLookup);
            p.classList.toggle('lu-selected', selected);
            if (selected) {
                g.appendChild(p);
            }
        });
    };
    SlopeGraph.prototype.matchLength = function (slopes, g) {
        var _this = this;
        var paths = Array.from(g.children);
        for (var i = slopes.size; i < paths.length; ++i) {
            var elem = paths[i];
            this.pool.push(elem);
            elem.remove();
        }
        var _loop_1 = function (i) {
            var elem = this_1.pool.pop();
            if (elem) {
                g.appendChild(elem);
                paths.push(elem);
            }
            else {
                console.assert(g.ownerDocument != null);
                var path_1 = g.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
                path_1.onclick = function (evt) {
                    var s = path_1.__data__;
                    var p = _this.ctx.provider;
                    var ids = s.dataIndices;
                    if (evt.ctrlKey) {
                        ids.forEach(function (id) { return p.toggleSelection(id, true); });
                    }
                    else {
                        var isSelected = p.isSelected(ids[0]);
                        p.setSelection(isSelected ? [] : ids);
                    }
                };
                g.appendChild(path_1);
                paths.push(path_1);
            }
        };
        var this_1 = this;
        for (var i = paths.length; i < slopes.size; ++i) {
            _loop_1(i);
        }
        return paths;
    };
    SlopeGraph.prototype.updateSelection = function (selectedDataIndices) {
        var g = this.node.firstElementChild;
        var paths = Array.from(g.children);
        paths.forEach(function (p) {
            var s = p.__data__;
            var selected = s.isSelected(selectedDataIndices);
            p.classList.toggle('lu-selected', selected);
            if (selected) {
                g.appendChild(p);
            }
        });
    };
    return SlopeGraph;
}());
export default SlopeGraph;
//# sourceMappingURL=SlopeGraph.js.map